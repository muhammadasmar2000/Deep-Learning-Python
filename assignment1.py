# -*- coding: utf-8 -*-
"""Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GHdxYSdJkEwXpdN3F-XXySuXXfL9xeLB

#Muhammad Asmar (Z23470131)
https://colab.research.google.com/drive/1GHdxYSdJkEwXpdN3F-XXySuXXfL9xeLB?usp=sharing

#Problem 1
"""

#import math library
import math 

#define functions
def add(a, b):
  return a + b

def subtract(a, b):
  return a - b

def multiply(a, b):
  return a * b

def divide(a, b):
  return a / b

def mod(a, b):
  return a % b

def pow(a, b):
  return a**b

def e(a):
  return math.exp(a)

def log(a):
  return math.log(a)

def abs(a):
  return math.fabs(a)

def get_float(prompt, error_message):
  while True:
    try:
      num = input(prompt)
      if num == "x":
        return num
      else: 
        num = float(num)
    except ValueError:
      print(error_message)
      continue
    return num

while(True):
  #ask for input
  print("Press 'x' to exit the calculator")
  num1 = get_float("Please enter a value to perfrom the operation: ", "Please enter a valid number")
  if num1 == "x":
    break
  print("Here is a list of operations:")
  print("Enter 1 for addition")
  print("Enter 2 for subtraction")
  print("Enter 3 for multiplication")
  print("Enter 4 for division")
  print("Enter 5 for modulus")
  print("Enter 6 for power")
  print("Enter 7 to take the e to the power of your number")
  print("Enter 8 to take the natural log of your number")
  print("Enter 9 to take the absolute value")
  operation = int(input("Please enter in an operation: "))
  #operations that only take one input
  if operation == 7:
    print("e to the power of {0} is {1:.2f}\n".format(num1, e(num1)))
  elif operation == 8:
    print("the natural log of {0} is {1:.2f}\n".format(num1, log(num1)))
  elif operation == 9:
    print("the absolute value of {0} is {1:.2f}\n".format(num1, abs(num1)))
  #ask for other another number
  else:
    print("Press 'x' to exit the calculator")
    num2 = get_float("Please enter another value to perform the operation: ", "Please enter a valid number")
    if operation == 1:
      print("{0} + {1} = {2:.2f}\n".format(num1, num2, add(num1,num2)))
    if operation == 2:
      print("{0} - {1} = {2:.2f}\n".format(num1, num2, subtract(num1,num2)))
    if operation == 3:
      print("{0} x {1} = {2:.2f}\n".format(num1, num2, multiply(num1,num2)))
    if operation == 4:
      print("{0} / {1} = {2:.2f}\n".format(num1, num2, divide(num1,num2)))
    if operation == 5:
      print("{0} mod {1} = {2:.2f}\n".format(num1, num2, mod(num1,num2)))
    if operation == 6:
      print("{0}^{1} = {2:.2f}\n".format(num1, num2, pow(num1,num2)))
#Program terminated
print("Thank you for using the python calculator")

"""#Problem 2"""

from matplotlib import pyplot as plt
#functions
#asks user to enter a float value and returns value
def get_float(prompt, error_message):
  while True:
    try:
      num = input(prompt)
      if num == "x":
        return num
      else: 
        num = float(num)
    except ValueError:
      print(error_message)
      continue
    return num

#returns the number of correctly classified points based on threshold values
def count_correct_classified(c1_x_array, c1_y_array, c2_x_array, c2_y_array, th_x, th_y):
  count = 0
  #count correctly classified points for C1
  for i in range(len(c1_x_array)):
    if c1_x_array[i] > th_x and c1_y_array[i] > th_y:
      count += 1
  #count correctly classified points for C2
  for j in range(len(c2_x_array)):
    if c2_x_array[j] <= th_x or c2_y_array[j] <= th_y:
      count += 1
  return count

#returns the recommended threshold value based on c1 and c2 arrays
def recommended_threshold(c1_array, c2_array):
  num = min(c1_array) - max(c2_array)
  if num == 0:
    return float(max(c2_array) - 0.1)
  else: 
    return float(max(c2_array) + (num/2.0))

#C1 coordinates
c1_x = [2,3,2]
c1_y = [2,2,3]
#C2 coordinates
c2_x = [1,1,2]
c2_y = [2,1,1]
plt.plot(c1_x, c1_y, "sg", label="C1") #green squares for C1
plt.plot(c2_x, c2_y, "^r", label="C2") #red triangles for C2
plt.xlabel("X: Feature 1")
plt.ylabel("Y: Feature 2")
plt.title("Plotted Graph")
plt.legend()
plt.show()

#repeatedly ask for 
while True:
  #ask for threshold values from user
  print("Recommended threshold value for x: {}".format(recommended_threshold(c1_x, c2_x)))
  th_x = get_float("Enter a threshold x-value: ", "Please enter a valid number as a threshold value")
  print("Recommended threshold value for y: {}".format(recommended_threshold(c1_y, c2_y)))
  th_y = get_float("Enter a threshold y-value: ", "Please enter a valid number as a threshold value")
  #print("Threshold values are: {0} and {1}".format(th_x, th_y))

  while True:
    #print correct classifications
    correct_classifications = count_correct_classified(c1_x, c1_y, c2_x, c2_y, th_x, th_y)
    print("Correctly classified points: {0}".format(correct_classifications))
    print("Training Accuracy: {0:.2f}%".format((correct_classifications/(len(c1_x) + len(c2_x)))*100.0))

    #ask user for data point
    print("Please enter the x and y value for a new data point")
    user_x = get_float("Enter an x-value: ", "Please enter a valid x-value as a data point") #CHECK IF THE USER ENTERS X AS AN INPUT
    if user_x == "x":
      break
    user_y = get_float("Enter an y-value: ", "Please enter a valid y-value as a data point") #CHECK IF THE USER ENTERS X AS AN INPUT
    if user_y == "x":
      break

    #remove the last user-entered data point in the arrays, if applicable
    if len(c1_x) == 4:
      c1_x.pop(3)
      c1_y.pop(3)
    if len(c2_x) == 4:
      c2_x.pop(3)
      c2_y.pop(3)

    #plot the user data point on the graph with correct classification based on threshold value
    if user_x > th_x and user_y > th_y:
      c1_x.append(user_x)
      c1_y.append(user_y)
      plt.plot(c1_x, c1_y, "sg", label="C1")
      plt.plot(c2_x, c2_y, "^r", label="C2")
      plt.xlabel("X: Feature 1")
      plt.ylabel("Y: Feature 2")
      plt.title("Plotted Graph")
      plt.legend()
      plt.show()
    else: 
      c2_x.append(user_x)
      c2_y.append(user_y)
      plt.plot(c1_x, c1_y, "sg", label="C1")
      plt.plot(c2_x, c2_y, "^r", label="C2")
      plt.xlabel("X: Feature 1")
      plt.ylabel("Y: Feature 2")
      plt.title("Plotted Graph")
      plt.legend()
      plt.show()

"""#Problem 3"""

from keras.datasets import mnist
import numpy as np
import matplotlib.pyplot as plt

#randomly draw images 0-9 function
def drawImages(x_array, y_array):
  plt.figure()
  for i in range(10):
    x_train_digit = x_array[y_array==i, :, :]
    plt.subplot(2, 5, i+1) #make a 2 row and 5 column subplot at position i+1
    x_train_image = x_train_digit[np.random.randint(0, x_train_digit.shape[0]), :, :] #select image randomly from x_train
    plt.imshow(x_train_image, cmap="gray")
    plt.title("Label: {}".format(i))
  plt.show()

#x_train contains the images that are 28 x 28 pixels and y_train are the labels to the images
(x_train, y_train), (x_test, y_test) = mnist.load_data()
print("Number of images in training set: {}".format(x_train.shape[0])) #60,000 images
print("Number of images in testing set: {}".format(x_test.shape[0])) #10,000 images
print("Image Width: {0}\nImage Height: {1}".format(x_train.shape[1], x_train.shape[2])) #28 x 28

#call drawImages function three times for training set
for i in range(3):
  print("Training Data Figure: " + str(i+1))
  drawImages(x_train, y_train)

#call drawImages function three times for testing set
for i in range(3):
  print("Testing Data Figure: " + str(i+1))
  drawImages(x_test, y_test)

#shuffle training set
num_train_img = x_train.shape[0]
train_ind = np.arange(0, num_train_img)
train_ind_shuffle = np.random.permutation(train_ind)
x_train = x_train[train_ind_shuffle, :, :]
y_train = y_train[train_ind_shuffle]

#select first 20% to be validation set
x_valid = x_train[0:int(.2*num_train_img), :, :]
y_valid = y_train[0:int(.2*num_train_img)]

#the rest is the training data
x_train = x_train[int(.2*num_train_img):, :, :]
y_train = y_train[int(.2*num_train_img):]

#print the number of images in each training and validation set
print("Number of images in training set: {}".format(x_train.shape[0]))
print("Number of images in validation set: {}".format(x_valid.shape[0]))